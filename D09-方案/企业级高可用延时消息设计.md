# 01 | 延时业务场景需求分析及落地实现

**延时需求**

- 即时通讯消息重发

IM 系统为了确保消息触达接收方，消息发出几秒后没有收到 ack，需要重发消息。

- 订单状态流转

取消规定时间内未付款的订单；商家发货后，长时间未确认的订单自动确认收货。

- 外置索引更新

信息发布后，外置索引更新相对滞后，立刻查询可能会查不到。

**解决方案：时间轮算法**

时间轮算法可以用于高效的执行大量的定时任务，实现简单，且精度非常高。原理如下：

![image-20210519230556425](https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20210519230556.png)

构造一个内存时间轮，桶数量为 15，时间粒度为秒。当消息发出后，将事件放入游标的前一个桶，当收到 ACK 后记录 ACK 事件，然后遍历当前桶，如果 15 秒之内没有收到客户端的 ACK 确认，则重新发送消息。逻辑设计图如下：

![image-20210519231302869](https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20210519231302.png)

时间轮存储选择 Redis 的 List 数据结构。Key 存储桶，String 存储游标。如下图所示：

![image-20210519231936647](https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20210519231936.png)

# 02 | 企业级延时服务架构设计

企业级的延时服务，需要适用更多的场景，支持不同跨度的延时；且需要多个节点提供服务，以确保服务的高可用。

![image-20210519232907492](https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20210519232907.png)

# 03 | 基于 RocketMQ 延时消息的代码级设计实现

**RocketMQ 原理**

![image-20210519233028019](https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20210519233028.png)

RocketMQ 支持 18 个级别的延时等级，默认值为 1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h。生产者发消息时通过设置 delayLevel 选择。

```java
// 生产者选择 delayLevel
public void setDelayTimeLevel(int level) {
  this.putProperty(MessageConst.PROPERTY_DELAY_TIME_LEVEL, String.valueOf(level));
}
```

**延时实现原理**

通过缓存延时消息到不同延时级别的队列 SCHEDULE_TOPIC_XXX，每个队列创建定时任务进行调度，延时消息到期后则重新投递到真实的 Topic。如下图所求：

![image-20210519233731588](https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20210519233731.png)

Broker 将所有接收到的消息顺序写入 CommitLog 中，Dispatch 线程负责将消息的索引信息分发到 Topic 的 Queue 中。

![image-20210519234319574](https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20210519234319.png)

**ScheduleLog 存储**

存放延时消息的一组文件，将延时消息按到期时间划分，以半小时位一个区间，存放到指定的 ScheduleLog 文件中。

- 消息索引

![image-20210519234626784](https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20210519234626.png)



