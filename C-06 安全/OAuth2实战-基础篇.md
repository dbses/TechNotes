# 开篇词 | 为什么要学OAuth 2.0？

触开放平台相关的技术，主要包括网关、授权两块的内容。

**怎么学习这门课？**

第一部分：必须要掌握的 OAuth2 的基础知识。会细致讲解授权码许可（Authorization Code）类型的流程，包括 OAuth2 内部组件之间的通信方式，以及授权服务、客户端（第三方软件）、受保护资源服务这三个组件的原理。

在此基础上，我还会为你讲解其他三种常见许可类型，分别是资源拥有者凭据许可 （Resource Owner Password Credentials）、隐式许可（Implicit）、客户端凭据许可 （Client Credentials）的原理，以及如何选择适合自己实际场景的授权类型。

学完基础篇的内容，你就可以把 OAuth 2.0 用到实际的工作场景了。

第二部分：侧重讲一些 OAuth2 更高级的用法，更安全、扩展性地使用 OAuth2。

包括如何在移动 App 中使用 OAuth 2.0，因使用不当而导致的 OAuth 2.0 安全漏洞有哪些，以及如何利用 OAuth 2.0 实现一个 OpenID Connect 用户身份认证协议。

[Github](github.com/xindongbook/oauth2-code)

OAuth 2.0 知识体系图：

![OAuth2](https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20201219231943.jpeg)

# 01 | OAuth 2.0是要通过什么方式解决什么问题？

**OAuth 2.0 是什么？**

用一句话总结来说，OAuth 2.0 就是一种授权协议。

假如你是一个卖家，在京东商城开了一个店铺， 日常运营中你要将订单打印出来以便给用户发货。但打印这事儿也挺繁琐的，之前你总是手工操作，后来发现有个叫“小兔”的第三方软件，它可以帮你高效率地处理这事。

小兔是怎么访问到这些订单数据的呢？其实是这样，京东商城提供了开放平台， 小兔通过京东商家开放平台的 API 就能访问到用户的订单数据。只要你在软件里点击同意，小兔就可以拿到一个访问令牌，通过访问令牌来获取到你的订单数据.

**为什么用 OAuth 2.0？**

OAuth 2.0 这种授权协议，就是保证第三方（软件）只有在获得授权之后， 才可以进一步访问授权者的数据。因此，我们常常还会听到一种说法，OAuth 2.0 是一种安全协议。

现在访问授权者的数据主要是通过 Web API，所以凡是要保护这种对外的 API 时，都需要 这样授权的方式。而 OAuth 2.0 的这种颁发访问令牌的机制，是再合适不过的方法了。同 时，这样的 Web API 还在持续增加，所以 OAuth 2.0 是目前 Web 上重要的安全手段之一 了。

**OAuth 2.0 是怎样运转的？**

![image-20201219233700427](https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20201219233700.png)

OAuth 2.0 授权的核心就是颁发访问令牌、使用访问令牌，而且不管是哪种类型的授权流程都是这样。

在小兔软件这个例子中呢，我们使用的就是授权码许可（Authorization Code）类型。此外，还有 3 种基础的许可类型，分别是隐式许可 （Implicit）、客户端凭据许可（Client Credentials）、资源拥有者凭据许可（Resource Owner Password Credentials）。

# 02 | 授权码许可类型中，为什么一定要有授权码？

上一讲，讲了 OAuth 2.0 的授权码许可类型。小兔打单软件的例子里面，小兔最终是通过访问令牌请求到小明的店铺里的订单数据。这个访问令牌是通过授权码换来的。

**为什么需要授权码？**

> 名词说明：
>
> 资源拥有者 -> 小明
> 第三方软件（客户端） - > 小兔软件
> 授权服务 -> 京东商家开放平台的授权服务
> 受保护资源 -> 小明店铺在京东上面的订单

OAuth 诞生之初就是为了解决 Web 浏览器场景下的授权问题，所以我基于浏览 器的场景，在上一讲的小明使用小兔软件打印订单的整体流程的基础上，画了一个授权码 许可类型的序列图。

![image-20201220121243904](https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20201220121243.png)

从图中看到，在第 4 步授权服务生成了授权码 code，按照一开始我们提出来的问题，如果不要授权码，这一步实际上就可以直接返回访问令牌 access_token 了。

如果没有授权码的话，我们就只能把访问令牌发送给第三方软件小兔的后端服务。因为使用重定向的方式，会把安全保密性要求极高的访问令牌暴露在浏览器上，从而将会面临访问令牌失窃的安全风险。显然，这是不能被允许的。上面的流程图就会变成下面这样：

![image-20201220123102175](https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20201220123102.png)

这样，问题就来了。当小明被浏览器重定向到授权服务上之后，小明跟小兔软件之间的 “连接” 就断了，相当于此时此刻小明跟授权服务建立了“连接”后，将一 直“停留在授权服务的页面上”。你会看到图 2 中问号处的时序上，小明再也没有重新“连接”到小兔软件。

为了让小明跟小兔软件重新建立起 “连接”，需要进行第二次重定向，小明授权之后，又重新重定向回到了小兔软件的地址上，这样小明就跟小兔软件有了新的 “连接”。

到这里，就能理解在授权码许可的流程中，为什么需要两次重定向了。

为了重新建立起这样的一次连接，我们又不能让访问令牌暴露出去，就有了这样一个临时的、间接的凭证：授权码。

小兔软件最终要拿到的是安全保密性要求极高的访问令牌，并不是授权码，而授权码是可以暴露在浏览器上面的。这样有了授权码的参与，访问令牌可以在后端服务之间传输，同时还可以重新建立小明与小兔软件之间的“连接”。 这样通过一个授权码，既“照顾”到了小明的体验，又“照顾”了通信的安全。

到这里，就知道了为什么要有授权码了。

那么，在执行授权码流程的时候，授权码和访问令牌在小兔软件和授权服务之间到底是怎么流转的呢？

**授权码许可类型的通信过程**

下面我们从直接通信和间接通信的维度来分析。所谓的间接通信就是指获取授权码的交互，而直接通信就是指通过授权码换取访问令牌的交互。

- 间接通信（通过授权码换取访问令牌的交互）

  ![image-20201220135304992](https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20201220135349.png)

  第三方软件小兔和授权服务之间，并没有发生直接的通信，而是通过浏览器这个“中间人” 来 “搭线”的。因此，我们说这是一个间接通信的方式。

- 直接通信（获取授权码的交互）

  ![image-20201220135443932](https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20201220135443.png)

  第三方软件小兔获取到授权码 code 值后，向授权服务发起获取访问令牌 access_token 通信请求。这个请求是第三方软件服务器跟授权服务的服务器之间的通信，都是在后端服务器之间的请求和响应，因此也叫作后端通信。

**两个 “一伙”**

OAuth 2.0 中的 4 个角色是 “两两 站队” 的：资源拥有者和第三方软件“站在一起”，因为第三方软件要代表资源拥有者去访问受保护资源；授权服务和受保护资源“站在一起”，因为授权服务负责颁发访问令牌，受保护资源负责接收并验证访问令牌。

![image-20201220221358951](https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20201220221358.png)

介绍授权码流程的时候我都是以浏览器参与的场景来讲的，那么浏览器一定要参与到这个流程中吗？

**一定要有浏览器吗？**

OAuth 2.0 发展之初，开放生态环境相对单薄，以浏览器为代理的 Web 应用居多，授权码许可类型 “理所当然” 地被应用到了通过浏览器才能访问的 Web 应用中。 

但实际上，OAuth 2.0 是一个授权理念，或者说是一种授权思维。它的授权码模式的思维 可以移植到很多场景中，比如微信小程序。在开发微信小程序应用时，我们通过授权码模 式获取用户登录信息，[官方文档的地址示例](https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/login/auth.code2Session.html)中给出的 grant_type=authorization_code ，就没有用到浏览器。

根据微信官方文档描述，开发者获取用户登录态信息的过程正是一个授权码的许可流程：

```
首先，开发者通过 wx.login(Object object) 方法获取到登录凭证 code 值，这一步的流程是在小程序内部通过调用微信提供的 SDK 实现；
然后，再通过该 code 值换取用户的 session_key 等信息，也就是官方文档的 auth.code2Session 方法，同时该方法也是被强烈建议通过开发者的后端服务来调用的。
```

你可以看到，这个过程并没有使用到浏览器，但确实按照授权码许可的思想走了一个完整 的授权码许可流程。也就是说，先通过小程序前端获取到 code 值，再通过小程序的后端服务使用 code 值换取 session_key 等信息，只不过是访问令牌 access_token 的值被换成了 session_key。

```

GET https://api.weixin.qq.com/sns/jscode2session?appid=APPID&secret=SECRET&js_code=JSCODE&grant_type=authorization_code
```

这整个过程体现的就是授权码许可流程的思想。







