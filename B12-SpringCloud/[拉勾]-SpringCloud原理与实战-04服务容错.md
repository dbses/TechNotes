# 12 | 服务容错：服务容错的思想和模式？

今天的内容关注服务容错的设计理念和与其相关的架构模式。

**为什么要实现服务容错？**

当访问服务 A 得不到正常的响应时，服务 B 的常见处理方式是通过重试机制来进一步加大对服务 A 的访问流量。这样，服务 B 每进行一次重试就会启动一批线程。

线程的不断创建是需要消耗系统资源的，一旦系统资源被耗尽，服务 B 本身也将变得不可用，这就是事故的第二个阶段：

<img src="https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20210309225911.png" alt="image-20210309225911832" style="zoom:50%;" />

类似的，如果系统中存在服务 C 等其他服务依赖服务 B......以此类推，最终在以服务 A 为起点的整个调用链路上的所有服务都会变得不可用。这种扩散效应就是所谓的服务雪崩效应。

**服务容错的模式**

消费者容错的常见实现模式包括集群容错、服务隔离、服务熔断和服务回退。

1. 集群容错

从设计思想上讲，容错机制的基本要素就是要做到冗余，即某一个服务应该构建多个实例，这样当一个服务实例出现问题时可以重试其他实例。

一个集群中的服务本身就是冗余的。而针对不同的重试方式就诞生了一批集群容错策略，常见的包括 Failover（失效转移）、Failback（失败通知）、Failsafe（失败安全）和 Failfast（快速失败）等。

失效转移指当服务调用发生异常时，请求会重新在集群中查找下一个可用的服务提供者实例。但为了防止无限重试，通常会对失败重试最大次数进行限制。

2. 服务隔离

所谓隔离，就是指对资源进行有效的管理，从而避免因为资源不可用、发生失败等情况导致系统中的其他资源也变得不可用。

日常开发过程中，主要还是使用线程级别的隔离。简单而主流的做法是使用线程池（Thread Pool）。针对不同的业务场景设计不同的线程池。

这样当某个线程池因为业务异常导致资源消耗时，不会将这种资源消耗扩散到其他线程池，从而保证其他服务持续可用。

3. 服务熔断

当系统中出现某一个异常情况时，能够直接熔断整个服务的请求处理过程。这样可以避免一直等到请求处理完毕或超时，从而避免浪费。

从设计理念上讲，服务熔断也是快速失败的一种具体表现。服务熔断器的基本结构，如下图所示：

<img src="https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20210309225026.png" alt="image-20210309225020619" style="zoom:50%;" />

4. 服务回退

服务回退（Fallback）的概念类似一种被动的、临时的处理机制。当远程调用发生异常时，服务回退并不是直接抛出异常，而是产生一个另外的处理机制来应对该异常。

服务回退不能解决由异常引起的实际问题，而是一种权宜之计。这种权宜之计在处理因为服务依赖而导致的异常时也是一种有效的容错机制。

**Spring Cloud 中的服务容错解决方案**

Spring Cloud 中专门用于提供服务容错功能的 Spring Cloud Circuit Breaker 框架，内置了四种熔断器：

- Netflix Hystrix
- Resilience4J
- Sentinel
- Spring Retry

针对以上四种熔断器，Spring Cloud Circuit Breaker 提供了统一的 API。

其中 Netflix Hystrix 显然来自 Netflix OSS；Resilience4j 是受 Hystrix 项目启发所诞生的一款新型的容错库；Sentinel 从定位上讲是一款包含了熔断降级功能的高可用流量防护组件；而最后的 Spring Retry 是 Spring 自研的重试和熔断框架。







